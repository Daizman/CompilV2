#include "Syntax.hpp"


Syntax::Syntax(string fIn, string fOut) {
	_lexer = new Lexer(fIn, fOut);
}

Syntax::~Syntax() {
	delete _lexer;
}

Lexer* Syntax::GetLexer() {
	return _lexer;
}

// <программа>::=program <имя>; <блок>.
void Syntax::BNFProg() {
	
}

// <блок>::=<раздел констант><раздел типов><раздел переменных><раздел операторов>
void Syntax::BNFBlock() {
	
}

// <раздел констант>::=<пусто>|const <определение константы>; {<определение константы>;}
void Syntax::BNFConsts() {

}

// <раздел типов>::=<пусто>|type <определение типа>; {<определение типа>;}
void Syntax::BNFTypes() {

}

// <раздел переменных>::=var <описание однотипных переменных>;{<описание однотипных переменных>;} | <пусто>
void Syntax::BNFVariants() {

}

// <раздел операторов>::=<составной оператор>
void Syntax::BNFOpers() {

}

// <определение константы>::=<имя>=<константа>
void Syntax::BNFConstDif() {

}

// <константа>::=<число без знака>|<знак><число без знака> | <имя константы> | <знак><имя константы> | <строка>
void Syntax::BNFConst() {
	
}

// <определение типа>::=<имя>=<тип>
void Syntax::BNFTypeDif() {
	
}

// <тип>::=<простой тип>
void Syntax::BNFType() {
	
}

// <простой тип>::=<перечислимый тип>|<ограниченный тип>|<имя типа>
void Syntax::BNFSimpleType() {

}

// <перечислимый тип>::=(<имя>{,<имя>})
void Syntax::BNFEnumType() {

}

// <ограниченный тип>::=<константа>..<константа>
void Syntax::BNFGroundedType() {
	
}

// <имя типа>::=<имя>
void Syntax::BNFTypeName() {
	
}

// <описание однотипных переменных>::=<имя>{,<имя>}:<тип>
void Syntax::BNFSingleTypeVariants() {
	
}

// <составной оператор>::= begin <оператор>{;<оператор>} end
void Syntax::BNFConcOper() {
	
}

// <оператор>::=<непомеченный оператор>
void Syntax::BNFOper() {

}

// <непомеченный оператор>::=<простой оператор>|<сложный оператор>
void Syntax::BNFNotMarkedOper() {

}

// <простой оператор>::=<оператор присваивания>|<оператор процедуры>|<пустой оператор>
void Syntax::BNFSimpleOper() {

}

// <оператор присваивания>::=<переменная>:=<выражение>|<имя функции>: = <выражение>
void Syntax::BNFOperAssigm() {

}

// <переменная>::=<полная переменная>|<указанная переменная>
void Syntax::BNFVar() {
	
}

// <полная переменная>::=<имя переменной>
void Syntax::BNFFullVar() {
	
}

// <имя переменной>::=<имя>
void Syntax::BNFVarName() {

}

// <указанная переменная>::=<переменная-ссылка>
void Syntax::BNFPointedVar() {
	
}

// <переменная-ссылка>::=<переменная>
void Syntax::BNFPointerVar() {
	
}

// <выражение>::=<простое выражение>|<простое выражение><операция отношения><простое выражение>
void Syntax::BNFExpres() {
	
}

// <операция отношения>::==|<>|<|<=|>=|>|in
void Syntax::BNFComperExpr() {
	
}

// <простое выражение>::=<знак><слагаемое>{<аддитивная операция><слагаемое>}
void Syntax::BNFSimpleExpr() {

}

// <аддитивная операция>::=+|-|or
void Syntax::BNFAdditOper() {

}

// <слагаемое>::=<множитель>{<мультипликативная операция><множитель>}
void Syntax::BNFSlag() {
	
}

// <мультипликативная операция>::=*|/|div|mod|and
void Syntax::BNFMultOper() {

}

// <множитель>::=<переменная>|<константа без знака>|(<выражение>) | <обозначение функции> | <множество> | not <множитель>
void Syntax::BNFMultiplier() {

}

// <обозначение функции>::=<имя функции>|<имя функции>(<фактический параметр>{, <фактический параметр>})
void Syntax::BNFFuncDif() {

}

// <имя функции>::=<имя>
void Syntax::BNFFuncName() {
	
}

// <фактический параметр>::=<выражение>|<переменная>|<имя процедуры> | <имя функции>
void Syntax::BNFFactParam() {

}

// <пустой оператор>::=<пусто>
void Syntax::BNFEmptyOper() {

}

// <пусто>::=
void Syntax::BNFEmpty() {

}

// <множество>::=[<список элементов>]
void Syntax::BNFSet() {

}

// <список элементов>:: = <элемент>{ ,<элемент> } | <пусто>
void Syntax::BNFElemsList() {

}

// <элемент>:: = <выражение> | <выражение>..<выражение>
void Syntax::BNFElement() {

}

// <имя процедуры>::=<имя>
void Syntax::BNFProcName() {

}

// <оператор процедуры>::=<имя процедуры>|<имя процедуры>(<фактический параметр>{, <фактический параметр>})
void Syntax::BNFProcOper() {

}

// <сложный оператор>::=<составной оператор>|<выбирающий оператор>
void Syntax::BNFBigOper() {
	
}

// <выбирающий оператор>::=<условный оператор>
void Syntax::BNFChooseOper() {
	
}

// <условный оператор>::= if <выражение> then <оператор>|if <выражение> then <оператор> else <оператор>
void Syntax::BNFIfOper() {

}
